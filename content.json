{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2020-04-12T06:21:49.000Z","updated":"2020-04-12T06:22:38.929Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-04-12T05:49:34.000Z","updated":"2020-04-12T05:55:49.236Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"力扣简单链表习题","slug":"力扣简单链表习题","date":"2020-05-19T13:18:19.011Z","updated":"2020-05-19T13:40:35.833Z","comments":true,"path":"2020/05/19/力扣简单链表习题/","link":"","permalink":"http://yoursite.com/2020/05/19/%E5%8A%9B%E6%89%A3%E7%AE%80%E5%8D%95%E9%93%BE%E8%A1%A8%E4%B9%A0%E9%A2%98/","excerpt":"力扣简单题解","text":"力扣简单题解 21. 合并两个有序链表将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode dummy(0); ListNode* tail&#x3D; &amp;dummy; while(l1 !&#x3D;nullptr&amp;&amp;l2 !&#x3D;nullptr) &#123; if(l1-&gt;val&lt;l2-&gt;val) &#123; tail-&gt;next &#x3D; new ListNode(l1-&gt;val); tail &#x3D; tail-&gt;next; l1 &#x3D; l1-&gt;next; &#125; else &#123; tail-&gt;next &#x3D; new ListNode(l2-&gt;val); tail &#x3D; tail-&gt;next; l2 &#x3D; l2-&gt;next; &#125; &#125; while(l1 !&#x3D; nullptr) &#123; tail-&gt;next &#x3D; new ListNode(l1-&gt;val); tail &#x3D; tail-&gt;next; l1 &#x3D; l1-&gt;next; &#125; while(l2 !&#x3D; nullptr) &#123; tail-&gt;next &#x3D; new ListNode(l2-&gt;val); tail &#x3D; tail-&gt;next; l2 &#x3D; l2-&gt;next; &#125; return dummy.next; &#125;&#125;; 83. 删除排序链表中的重复元素给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 示例 1: 输入: 1-&gt;1-&gt;2输出: 1-&gt;2示例 2: 输入: 1-&gt;1-&gt;2-&gt;3-&gt;3输出: 1-&gt;2-&gt;3 12345678910111213141516171819class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; ListNode* cur&#x3D;head; while(cur !&#x3D;nullptr &amp;&amp;cur-&gt;next !&#x3D;nullptr) &#123; if(cur-&gt;val&#x3D;&#x3D;cur-&gt;next-&gt;val) &#123; cur-&gt;next&#x3D;cur-&gt;next-&gt;next; &#125; else &#123; cur&#x3D;cur-&gt;next; &#125; &#125; return head; &#125;&#125;; 141. 环形链表给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 示例 1： 输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 输入：head = [1,2], pos = 0输出：true解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 输入：head = [1], pos = -1输出：false解释：链表中没有环。 进阶： 你能用 O(1)（即，常量）内存解决此问题吗？ 123456789101112131415161718class Solution &#123;public: bool hasCycle(ListNode *head) &#123; ListNode* fast &#x3D; head; ListNode* slow &#x3D; head; while(fast !&#x3D;nullptr &amp;&amp; fast-&gt;next !&#x3D; nullptr) &#123; fast &#x3D; fast-&gt;next-&gt;next; slow &#x3D; slow-&gt;next; if(fast &#x3D;&#x3D; slow) &#123; return true; &#125; &#125; return false; &#125;&#125;; 160. 相交链表编写一个程序，找到两个单链表相交的起始节点。 如下面的两个链表：在节点 c1 开始相交。 示例 1：输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3输出：Reference of the node with value = 8输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2：输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1输出：Reference of the node with value = 2输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3：输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2输出：null输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。解释：这两个链表不相交，因此返回 null。 注意： 如果两个链表没有交点，返回 null. 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。12345678910111213141516class Solution &#123;public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) &#123; if(headA &#x3D;&#x3D; nullptr || headB &#x3D;&#x3D; nullptr) return nullptr; ListNode* p &#x3D; headA; ListNode* q &#x3D; headB; while(p !&#x3D; q) &#123; p &#x3D;&#x3D; nullptr? p &#x3D; headB :p &#x3D; p-&gt;next; q &#x3D;&#x3D; nullptr? q &#x3D; headA :q &#x3D; q-&gt;next; &#125; return p; &#125;&#125;; 203. 移除链表元素删除链表中等于给定值 val 的所有节点。 示例: 输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6输出: 1-&gt;2-&gt;3-&gt;4-&gt;5 1234567891011121314151617181920212223class Solution &#123;public: ListNode* removeElements(ListNode* head, int val) &#123; ListNode dummy(0); ListNode* tail &#x3D; &amp;dummy; tail-&gt;next &#x3D; head; ListNode* cur &#x3D; tail; while(cur-&gt;next !&#x3D;nullptr) &#123; if(cur-&gt;next-&gt;val &#x3D;&#x3D; val) &#123; cur-&gt;next&#x3D;cur-&gt;next-&gt;next; &#125; else &#123; cur &#x3D; cur-&gt;next; &#125; &#125; return dummy.next; &#125;&#125;; 206. 反转链表反转一个单链表。 示例: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL进阶:你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ 1234567891011121314151617class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; ListNode* pre &#x3D; nullptr; ListNode* cur &#x3D; nullptr; ListNode* temp &#x3D; head; while(temp !&#x3D; nullptr) &#123; pre &#x3D; cur; cur &#x3D; temp; temp &#x3D; cur-&gt;next; cur-&gt;next &#x3D; pre; &#125; return cur; &#125;&#125;; 234. 回文链表示例 1: 输入: 1-&gt;2输出: false示例 2: 输入: 1-&gt;2-&gt;2-&gt;1输出: true进阶：你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？ 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: bool isPalindrome(ListNode* head) &#123; if(!head || !head-&gt;next ) &#123; return true; &#125; &#x2F;&#x2F;将slow指针放置中间位置 ListNode* slow &#x3D; head; ListNode* fast &#x3D; head; while(fast &amp;&amp;fast-&gt;next) &#123; slow &#x3D; slow-&gt;next; fast &#x3D; fast-&gt;next-&gt;next; &#125; &#x2F;&#x2F;反转后半部分 ListNode* cur &#x3D; slow; ListNode* nextNode &#x3D; slow-&gt;next; while(nextNode) &#123; ListNode* tmp &#x3D; nextNode-&gt;next; nextNode-&gt;next &#x3D; cur; cur &#x3D; nextNode; nextNode &#x3D; tmp; &#125; slow-&gt;next &#x3D; nullptr; &#x2F;&#x2F;开始比较 while(head &amp;&amp; cur) &#123; if(head-&gt;val !&#x3D; cur-&gt;val) &#123; return false; &#125; head &#x3D; head-&gt;next; cur &#x3D; cur-&gt;next; &#125; return true; &#125;&#125;; 237. 删除链表中的节点请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。 现有一个链表 – head = [4,5,1,9]，它可以表示为: 示例 1: 输入: head = [4,5,1,9], node = 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.示例 2: 输入: head = [4,5,1,9], node = 1输出: [4,5,9]解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9. 说明: 链表至少包含两个节点。链表中所有节点的值都是唯一的。给定的节点为非末尾节点并且一定是链表中的一个有效节点。不要从你的函数中返回任何结果。 1234567class Solution &#123;public: void deleteNode(ListNode* node) &#123; node-&gt;val &#x3D; node-&gt;next-&gt;val; node-&gt;next &#x3D; node-&gt;next-&gt;next; &#125;&#125;; 876. 链表的中间结点给定一个带有头结点 head 的非空单链表，返回链表的中间结点。 如果有两个中间结点，则返回第二个中间结点。 示例 1： 输入：[1,2,3,4,5]输出：此列表中的结点 3 (序列化形式：[3,4,5])返回的结点值为 3 。 (测评系统对该结点序列化表述是 [3,4,5])。注意，我们返回了一个 ListNode 类型的对象 ans，这样：ans.val = 3, ans.next.val = 4, ans.next.next.val = 5, 以及 ans.next.next.next = NULL. 示例 2： 输入：[1,2,3,4,5,6]输出：此列表中的结点 4 (序列化形式：[4,5,6])由于该列表有两个中间结点，值分别为 3 和 4，我们返回第二个结点。 提示： 给定链表的结点数介于 1 和 100 之间。 12345678910111213class Solution &#123;public: ListNode* middleNode(ListNode* head) &#123; ListNode* slow &#x3D; head; ListNode* fast &#x3D; head; while(fast !&#x3D; nullptr &amp;&amp;fast-&gt;next !&#x3D;nullptr) &#123; slow &#x3D; slow-&gt;next; fast &#x3D; fast-&gt;next-&gt;next; &#125; return slow; &#125;&#125;; 1290. 二进制链表转整数给你一个单链表的引用结点 head。链表中每个结点的值不是 0 就是 1。已知此链表是一个整数数字的二进制表示形式。 请你返回该链表所表示数字的 十进制值 。 示例 1：输入：head = [1,0,1]输出：5解释：二进制数 (101) 转化为十进制数 (5) 示例 2：输入：head = [0]输出：0 示例 3：输入：head = [1]输出：1 示例 4：输入：head = [1,0,0,1,0,0,1,1,1,0,0,0,0,0,0]输出：18880 示例 5：输入：head = [0,0]输出：0 提示： 链表不为空。链表的结点总数不超过 30。每个结点的值不是 0 就是 1。 12345678910111213class Solution &#123;public: int getDecimalValue(ListNode* head) &#123; ListNode* cur &#x3D; head; int sum &#x3D; 0; while(cur !&#x3D; nullptr) &#123; sum &#x3D; sum * 2 + cur-&gt;val; cur &#x3D; cur-&gt;next; &#125; return sum; &#125;&#125;;","categories":[],"tags":[]},{"title":"力扣中等链表习题","slug":"力扣中等链表习题","date":"2020-05-19T12:47:09.398Z","updated":"2020-05-19T13:12:05.680Z","comments":true,"path":"2020/05/19/力扣中等链表习题/","link":"","permalink":"http://yoursite.com/2020/05/19/%E5%8A%9B%E6%89%A3%E4%B8%AD%E7%AD%89%E9%93%BE%E8%A1%A8%E4%B9%A0%E9%A2%98/","excerpt":"力扣中等题解","text":"力扣中等题解 2. 两数相加给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例： 输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 1234567891011121314151617181920class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode dummy(0); ListNode* tail &#x3D; &amp;dummy; int sum &#x3D; 0; while(l1 !&#x3D; nullptr || l2 !&#x3D; nullptr || sum &gt; 0) &#123; sum +&#x3D; (l1 !&#x3D; nullptr?l1-&gt;val:0) + (l2 !&#x3D; nullptr?l2-&gt;val:0); l1 &#x3D; l1 !&#x3D; nullptr ? l1-&gt;next :nullptr; l2 &#x3D; l2 !&#x3D; nullptr ? l2-&gt;next :nullptr; tail-&gt;next &#x3D; new ListNode(sum % 10); sum &#x3D; sum &#x2F; 10; tail &#x3D; tail-&gt;next; &#125; return dummy.next; &#125;&#125;; 19. 删除链表的倒数第N个节点给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例： 给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2. 当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.说明： 给定的 n 保证是有效的。 1234567891011121314151617181920212223class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; ListNode dummy(0); ListNode* tail &#x3D; &amp;dummy; tail-&gt;next &#x3D; head; ListNode* fast &#x3D; &amp;dummy; ListNode* slow &#x3D; &amp;dummy; for(int i &#x3D; 0;i &lt; n; i++) &#123; fast &#x3D; fast-&gt;next; &#125; while(fast-&gt;next !&#x3D; nullptr) &#123; fast &#x3D; fast-&gt;next; slow &#x3D; slow-&gt;next; &#125; slow-&gt;next &#x3D; slow-&gt;next-&gt;next; return dummy.next; &#125;&#125;; 24. 两两交换链表中的节点给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 示例: 给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3. 1234567891011121314151617181920class Solution &#123;public: ListNode* swapPairs(ListNode* head) &#123; ListNode dummy(0); ListNode* pre &#x3D; &amp;dummy; pre-&gt;next &#x3D; head; while(pre-&gt;next !&#x3D; nullptr &amp;&amp;pre-&gt;next-&gt;next !&#x3D; nullptr) &#123; ListNode* cur &#x3D; pre-&gt;next; ListNode* future &#x3D; pre-&gt;next-&gt;next; pre-&gt;next &#x3D; future; cur-&gt;next &#x3D; future-&gt;next; future-&gt;next &#x3D; cur; pre&#x3D; pre-&gt;next-&gt;next; &#125; return dummy.next; &#125;&#125;; 61. 旋转链表给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。示例 1: 输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2输出: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL解释:向右旋转 1 步: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL向右旋转 2 步: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL 示例 2: 输入: 0-&gt;1-&gt;2-&gt;NULL, k = 4输出: 2-&gt;0-&gt;1-&gt;NULL解释:向右旋转 1 步: 2-&gt;0-&gt;1-&gt;NULL向右旋转 2 步: 1-&gt;2-&gt;0-&gt;NULL向右旋转 3 步: 0-&gt;1-&gt;2-&gt;NULL向右旋转 4 步: 2-&gt;0-&gt;1-&gt;NULL 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: ListNode* rotateRight(ListNode* head, int k) &#123; if(head &#x3D;&#x3D; nullptr) return head; ListNode* fast &#x3D; head; ListNode* slow &#x3D; head; &#x2F;&#x2F;求链表长度 ListNode* len &#x3D; head; int n &#x3D; 1; while(len-&gt;next !&#x3D; nullptr) &#123; n++; len &#x3D; len-&gt;next; &#125; k &#x3D; k % n; if(k &#x3D;&#x3D; 0) &#123; return head; &#125; for(int i &#x3D; 0 ; i&lt;k ; i++) &#123; fast &#x3D; fast-&gt;next; &#125; while(fast-&gt;next !&#x3D; nullptr) &#123; fast &#x3D; fast-&gt;next; slow &#x3D; slow-&gt;next; &#125; ListNode* newhead &#x3D; slow-&gt;next; slow-&gt;next &#x3D; nullptr; fast-&gt;next &#x3D; head; return newhead; &#125;&#125;; 82. 删除排序链表中的重复元素 II给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。 示例 1: 输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5输出: 1-&gt;2-&gt;5 示例 2: 输入: 1-&gt;1-&gt;1-&gt;2-&gt;3输出: 2-&gt;3 12345678910111213141516171819202122232425262728class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; ListNode thead &#x3D; ListNode(-1); thead.next &#x3D; head; ListNode* pre; ListNode* cur &#x3D; &amp;thead; int t; while(cur) &#123; pre &#x3D; cur; cur &#x3D; cur-&gt;next; while(cur &amp;&amp; cur-&gt;next &amp;&amp; cur-&gt;next-&gt;val &#x3D;&#x3D; cur-&gt;val) &#123; t &#x3D; cur-&gt;val; while(cur &amp;&amp; cur-&gt;val &#x3D;&#x3D; t) &#123; cur &#x3D; cur-&gt;next; &#125; &#125; pre-&gt;next &#x3D; cur; &#125; return thead.next; &#125;&#125;;","categories":[],"tags":[]},{"title":"第三篇文章","slug":"第三篇文章","date":"2020-04-11T14:04:42.150Z","updated":"2020-04-12T08:24:20.773Z","comments":true,"path":"2020/04/11/第三篇文章/","link":"","permalink":"http://yoursite.com/2020/04/11/%E7%AC%AC%E4%B8%89%E7%AF%87%E6%96%87%E7%AB%A0/","excerpt":"title:第三章：一些小设置","text":"title:第三章：一些小设置 第三章-对博客的一些设置1.写博客目前我在用的文本编辑https://marxi.co/这是一个在线的Markdown文本编辑的网页，因为博客上的文本文件都是md结尾的，也就是markdown。 2.将数据保存本地将你在这个网页写好的数据ctrl+a全选复制，在之前创建的blog文件夹中找到source，再找到_posts，这里就可以看到你博客上的文章，现在，你可以新建一个文本文件，记住文件要以md结尾，接着，用vscode或者nodepad++打开该文件，将复制好的内容直接粘贴。保存即可 其中上下三个—之间可以写一个标题。 3.上传依旧是三部曲：在get bash here 中依次输入hexo clean ,hexo g可以hexo s看看本地有没有生成，接着hexo d上传到仓库，过一会刷新一下你的博客就会出现了 4.更改主题https://github.com/fi3ework/hexo-theme-archer以我在用的主题为例，点进去，其实可以看到它教你怎样安装了。 5.更改头像找到blog下的themes文件，找到你当前用的主题文件夹，打开，可以看到一个叫_config.yml的文件，这个和blog根目录下的文件名相同，但这个是主题配置文件。以vscode或notepad++打开它，其中找到avatar，这个就是头像，更改你想换的头像链接，保存。接着就是hexo clean,hexo g,hexo s,hexo d了，过一会就会生成了。 看不懂的话就看这个小姐姐的视频，简单明了https://www.bilibili.com/video/BV1zp411R7gz?t=1849","categories":[],"tags":[]},{"title":"第二篇文章","slug":"第二篇文章","date":"2020-04-11T06:04:59.438Z","updated":"2020-04-12T08:24:30.033Z","comments":true,"path":"2020/04/11/第二篇文章/","link":"","permalink":"http://yoursite.com/2020/04/11/%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/","excerpt":"title：第二章-连接仓库","text":"title：第二章-连接仓库 将本地数据部署到云端—上一章我们介绍了在本地搭建一个服务器并且成功运行测试，这次我们把它部署到云端，让别人也可以访问我们的网站，我是部署到github的，网上有些人推荐部署到国内的coding，也就是腾讯云，或者阿里云，我自己一开始是试着搞coding，但是我觉得太麻烦了就放弃了，还是选择了github。 1.github仓库首先，部署到github总该有个账号吧，注册登录后，直接右上角找到new repository，即创建一个仓库(注意！仓库命名开头一定要是你自己的昵称)。这个仓库就是存你hexo数据的地方,相当于一个有我们博客数据的云文件,现在我们继续回到bit bash小黑框中进行操作,输入cnpm install –save hexo-deployer-git安装git插件。这个插件相当于是沟通你本地数据与github仓库的通道,之后在每次本地数据编辑完后都要用到它,现在有了通道,本地数据,还有部署的仓库,只差怎样部署了。 2.修改配置文件右键blog目录下的_config.yml文件，选择用notepad++,或者vscode，没有的话就下载一个吧，尽量不要用记事本。我用的第一个。打开后拉到最底下，找到deploy: type: git repo: https://github.com/codesun99/codesun99.github.io.git branch: master类似于这种格式，deploy下面没有的就自己把代码打上去，其中冒号后面要加一个空格。repo这一行写上你github新建仓库的地址。这步也可以在命令行中实现，我不会。 3.部署到仓库在小黑框输入hexo d进行最后的部署到远端的操作。这个过程中它会让你输入你的github昵称和密码，到最后如果你看到有deploy done：git说明成功了，这是你刷新一下你的github仓库，可以看到多了一些东西，其实就是博客生成的内容。这时候，你把仓库名的网址后面的部分复制出来。像我的github网址就是https://github.com/codesun99/codesun99.github.io，这时把最后一个斜杠后面的部分，也就是codesun99.github.io拿出来，复制到浏览器直接访问，就可以看到你新建好的博客啦！","categories":[],"tags":[]},{"title":"我的第一篇博客文章","slug":"我的第一篇博客文章","date":"2020-04-10T03:03:55.522Z","updated":"2020-04-12T08:20:11.264Z","comments":true,"path":"2020/04/10/我的第一篇博客文章/","link":"","permalink":"http://yoursite.com/2020/04/10/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/","excerpt":"title:第一章-关于本地环境的搭建","text":"title:第一章-关于本地环境的搭建 hexo+next主题搭建及美化(win10)首先，十分感谢羊哥（codesheep）的视频：手把手教你创建个人博客https://www.bilibili.com/video/BV1Yb411a7ty，让我能够如此轻易的创建了一个属于自己的博客。 之前我再朋友圈看到班长创建了一个博客，自己原本也想有个地方存储一下自己的学习心得，代码啊什么的，我也在网上找了许多的教程，但是质量都是参差不齐，理解和操作起来有些困难。后来看到羊哥的视频，让我感觉到即使我不会命令行操作，也能够理解其中的意思。 ##搭建 软件准备1.node.js因为 hexo 是基于 node 框架的，所以呢，我们首先需要下载安装node.js。下载地址：https://nodejs.org/en/ 选择左边LTS那个。 2.gitgit官方网站：https://git-scm.com/download/win 根据系统选择位数。官方下载安装包可能会很慢，这是我们选择国内的淘宝npm镜像下载：https://npm.taobao.org/mirrors/git-for-windows/ 安装就一直点击下一步，安装在哪个盘都无所谓，设置就系统默认就行。 3.hexo在你喜欢的一个盘内新建一个文件夹，名字叫blog，然后在空白处右键鼠标，有个get bash here的选项，点它。这时出来一个黑框，输入node -v查看一下node的版本，输入npm -v查看npm的版本，注意中间有空格。 检查是否安装成功，没有的话就重新安装node。 4.cnpm接下来安装cnpm,之后要用它装hexo。在终端上（就是小黑框）输入npm install -g cnpm –registry=https://registry.npm.taobao.org （淘宝镜像）不用这个的话下载速度慢而且容易失败。 安装好后输入cnpm 和cnpm -v，如果成功可以看到相应的一些文件。 5.hexo小黑框输入cnpm install -g hexo-cli，安装好用hexo -v验证一下。出现一列数据就是成功了。 至此，所需软件都安装完成。本地搭建现在输入pwd，看看当前文件在什么位置，应该就在你创建的路径中。然后，运行命令hexo init （这步是关键），结果你可以看到你创建的blog文件里多了一些东西（都是hexo为你生成的），这个文件夹相当于你以后的博客文件夹，如果有什么步骤做错了，可以直接把blog删掉重来。 运行测试最后，有三个命令会经常用到hexo clean //清理缓存文件hexo g//生成文件hexo s//运行本地服务器 第三步运行服务器后，会出现hexo is running at http://localhost.4000.press Ctrl+c to stop 这时，你打开浏览器，在网址栏输入localhost.4000。如果可以看到hexo为你生成的hello界面，说明本地环境搭建完成，你成功了。 其余内容请看下一章。","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2020-04-09T15:08:16.499Z","updated":"2020-04-12T06:27:11.345Z","comments":true,"path":"2020/04/09/hello-world/","link":"","permalink":"http://yoursite.com/2020/04/09/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"我的第一篇博客文章","slug":"我的第一篇博客文章","permalink":"http://yoursite.com/tags/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"},{"name":"第二篇文章","slug":"第二篇文章","permalink":"http://yoursite.com/tags/%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/"},{"name":"第三篇文章","slug":"第三篇文章","permalink":"http://yoursite.com/tags/%E7%AC%AC%E4%B8%89%E7%AF%87%E6%96%87%E7%AB%A0/"}]}],"categories":[],"tags":[{"name":"我的第一篇博客文章","slug":"我的第一篇博客文章","permalink":"http://yoursite.com/tags/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/"},{"name":"第二篇文章","slug":"第二篇文章","permalink":"http://yoursite.com/tags/%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/"},{"name":"第三篇文章","slug":"第三篇文章","permalink":"http://yoursite.com/tags/%E7%AC%AC%E4%B8%89%E7%AF%87%E6%96%87%E7%AB%A0/"}]}